use heck::*;
use std::io::{Read, Write};
use std::mem;
use std::path::Path;
use std::process::{Command, Stdio};
use witx::*;

use crate::{record_contains_union, render_highlevel, to_rust_ident};

pub fn generate<P: AsRef<Path>>(with_paths: &[P]) -> String {
    let doc = witx::load(witx_paths).unwrap();

    let mut raw = String::new();
    raw.push_str(
        "\
// This file is automatically generated, DO NOT EDIT
//
// To regenerate this file run the `crates/witx-bindgen` command"
    );
    for ty in doc.typenames() {
        ty.render_asc(&mut raw);
        raw.push_str("\n");
    }
    for m in doc.modules() {
        m.render_asc(&mut raw);
        raw.push_str("\n");
    }
    for c in doc.constants() {
        ascdoc(&c.docs, &mut raw);
        raw.push_str(&format!(
            "public const {}_{}: {} = {};\n",
            c.ty.as_str().to_shouty_snake_case(),
            c.name.as_str().to_shouty_snake_case(),
            c.ty.as_str().to_shouty_snake_case(),
            c.value
        ));
    }
    raw
}

/// Render witx to assemblyscript
trait RenderAsc {
    fn render_asc(&self, src: &mut String);
}

impl RenderAsc for NamedType {
    fn render_asc(&self, src: &mut String) {
        let name = self.name.as_str();
        match &self.tref {
            TypeRef::Value(ty) => match &**ty {
                Type::Record(s) => render_record(src, name, s),
                Type::Handle(h) => render_handle(src, name, h),
                Type::Variant(h) => render_variant(src, name, h),
                Type::List { .. }
                | Type::Pointer { .. }
                | Type::ConstPointer { .. }
                | Type::Builtin { .. } => render_alias(src, name, &self.tref),
            },
            TypeRef::Name(_nt) => render_alias(src, name, &self.tref),
        }
    }
}

fn render_record(src: &mut String, name: &str, s: &RecordDatatype) {
    match s.bitflags_repr() {
        Some(repr) => {
            src.push_str(&format!("type {} = ", name.to_camel_case()));
            repr.render_asc(src);
            src.push(';');
            for (i, member) in s.members.iter().enumerate() {
                ascdoc(&member.docs, src);
                src.push_str(&format!(
                    "public const {}_{}: {} = 1 << {};\n",
                    name.to_shouty_snake_case(),
                    member.name.as_str().to_shouty_snake_case(),
                    name.to_camel_case(),
                    i,
                ));
            }
        },
        None => {
            src.push_str("@unmanaged\n");
            src.push_str(&format!("public class {} {{\n", name.to_camel_case()));
            for member in s.members.iter() {

            }
        }
    }
}

impl RenderAsc for Module {
    fn render_asc(&self, src: &mut String) {
        for f in self.funcs() {
            render_asc_highlevel(&f, &self.name, src);
            src.push_str("\n\n");
        }

        let rust_name = self.name.as_str().to_snake_case();
        src.push_str("export namespace ");
        src.push_str(&rust_name);
        src.push_str(" {\n");
        //src.push_str("export declare")
        for f in self.funcs() {
            f.render_asc(src);
            src.push('\n');
        }
        src.push_str("}");
    }
}

fn render_asc_highlevel(func: &InterfaceFunc, module: &Id, src: &mut String) {
    let mut rust_name = String::new();
    func.name.render_asc(&mut rust_name);
    let rust_name = rust_name.to_snake_case();
    ascdoc(&fun.docs, src);
    ascdoc_params(&func.params, "Parameters", src);
    ascdoc_params(&func.results, "Return", src);

    // Render the function and its arguments, and note that the arguments here
    // are the exact type name arguments as opposed to the pointer/length pair
    // ones. These functions are unsafe because they work with integer file
    // descriptors, which are effectively forgeable and danglable raw pointers
    // into the file descriptor address space.
    src.push_str("pub function ");

    if cfg!(feature = "multi-module") {
        src.push_str(&[module.as_str().to_snake_case().as_str(), &rust_name].join("_"));
    } else {
        src.push_str(to_asc_ident(&rust_name));
    }

    src.push_str("(");
    for param in func.params.iter() {
        param.name.render_asc(src);
        src.push_str(": ");
        param.tref.render_asc(src);
        src.push_str(",");
    }
    src.push_str(")");

    match func.results.len() {
        0 => {}
        1 => {
            src.push_str(": ");
            func.results[0].tref.render_asc(src);
        }
        _ => {
            src.push_str(": (");
            for result in func.results.iter() {
                result.tref.render_asc(src);
                src.push_str(", ");
            }
            src.push_str(")");
        }
    }
    src.push_str("{");

    /*TODO AssemblyScript bindgen
    func.call_wasm(module, )*/

    src.push_str("}");
}

impl RenderAsc for InterfaceFunc {
    fn render_asc(&self, src: &mut String) {
        ascdoc(&self.docs, src);
        if self.name.as_str() != self.name.as_str().to_snake_case() {
            src.push_str("@external(\"");
            src.push_str(self.name.as_str());
            src.push_str("\")\n");
        }
        src.push_str("export declare function ");
        let mut name = String::new();
        self.name.render_asc(&mut name);
        src.push_str(to_rust_ident(&name.to_snake_case()));

        let (params, results) = self.wasm_signature();
        assert!(results.len() <= 1);
        src.push_str("(");
        for (i, param) in params.iter().enumerate() {
            src.push_str(&format!("arg{}: ", i));
            param.render_asc(src);
            src.push_str(",");
        }
        src.push_str(")");

        if self.noreturn {
            src.push_str(": void");
        } else if let Some(result) = results.get(0) {
            src.push_str(": ");
            result.render_asc(src);
        }
        src.push_str(";");
    }
}

fn ascdoc_params(docs: &[InterfaceFuncParam], header: &str, dst: &mut String) {
    let docs = docs
        .iter()
        .filter(|param| param.docs.trim().len() > 0)
        .collect::<Vec<_>>();
    if docs.len() == 0 {
        return;
    }

    dst.push_str("/**\n");
    dst.push_str(" ## ");
    dst.push_str(header);
    dst.push_str("\n\n");

    for param in docs {
        for (i, line) in param.docs.lines().enumerate() {
            if header != "Return" {
                if i == 0 {
                    dst.push_str("* `");
                    param.name.render_asc(dst);
                    dst.push_str(" ` - ");
                } else {
                    dst.push_str("  ");
                }
            }
            dst.push_str(line);
            dst.push('\n');
        }
    }
}

fn to_asc_ident(s: &str) -> &str {
    match s {
        "in" => "in_",
        "type" => "type_",
        "yield" => "yield_",
        "class" => "class_",
        s => s,
    }
}

impl RenderAsc for Id {
    fn render_asc(&self, src: &mut String) {
        src.push_str(to_asc_ident(self.as_str()))
    }
}

impl RenderAsc for WasmType {
    fn render_asc(&self, src: &mut String) {
        match self {
            WasmType::I32 => src.push_str("i32"),
            WasmType::I64 => src.push_str("i64"),
            WasmType::F32 => src.push_str("f32"),
            WasmType::F64 => src.push_str("f64"),
        }
    }
}

fn ascdoc(docs: &str, dst: &mut String) {
    if docs.trim().is_empty() {
        return;
    }
    dst.push_str("/**");
    for line in docs.lines() {
        dst.push_str(" * ")
        dst.push_str(line);
        dst.push('\n');
    }
    dst.push_str(" */");
}